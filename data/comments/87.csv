,username,comment_created_utc,comment_score,comment_text
0,RomanRiesen,1652285409.0,170.0,The air is sparkling with anticipation for what the most loved programming language might be this year!
1,OS6aDohpegavod4,1652287639.0,87.0,"Let's make Rust win ""most loved programming language"" for the 7th year in a row!"
2,kibwen,1652293796.0,114.0,"Heh, at this point I'm just waiting for the year that Rust doesn't win ""most loved programming language"", because that will mean that people are finally being forced to use Rust at their jobs. :P"
3,j_platte,1652344783.0,25.0,Triggered by aggregation of blockchain and decentralization into a single question 💢
4,InsanityBlossom,1652296836.0,10.0,Can’t wait for Survey 2027: “Rust is the most wanted language” (though unlikely we can beat Python and JS) 🙂
5,imral,1652312385.0,9.0,"> If you use security or ad-blocking plugins, you may see error messages

> To avoid error messages that prevent you from taking the survey, please try specifically unblocking Qualtrics in your plugin or pausing the plugin while you take the survey. 

Thanks but no thanks."
6,Programmurr,1652301116.0,19.0,"There isn't much questioning about programming language usage and preference.  My impression is that the ""most loved language"" category was killed off.

In case I'm wrong, everyone should still complete the survey."
7,RelevantTrouble,1652311529.0,2.0,I wonder if Salesforce is still blacklisted from the most dreaded list.
8,murlakatamenka,1652297790.0,1.0,"> Ah shit, here we go again."
9,tema3210,1652294913.0,1.0,"Btw, internal reddit webview crashes on survey"
10,,1652332360.0,1.0,[deleted]
11,,1652301922.0,-34.0,[removed]
12,JonaldLovesDong,1652285742.0,82.0,I hope it will be Brainfuck!
13,Sapiogram,1652305398.0,22.0,":D it's a self-fulfilling prophecy at this point, the entire Rust community is set on making it happen."
14,CongrachuBot,1652441135.0,0.0,"Congrachulations, out of all posts made on 11th May (UTC) in r/rust, yours was the topmost comment (out of 388 total comments).

Shine on!"
15,hgwxx7_,1652293974.0,47.0,That’s one theory. The other theory is that Rustaceans are suffering heavily from Stockholm syndrome. We spent so much time and effort learning the language that we’re hostages now. So people using it at work would only increase Rust’s loved %.
16,Trk-5000,1652297785.0,5.0,The only way I can see that happen is if some Rust-based dialect with GC becomes popular. Would definitely give it the edge on the higher levels of the tech stacks.
17,U007D,1652364725.0,8.0,"Ditto.  Separate blockchain, crypto and decentralization and I would give very different answers. :("
18,CornedBee,1652357610.0,4.0,Came to post this too.
19,drogus,1652387297.0,2.0,"same, I answered that I'm not interested at all, but only because of crypto. Decentralization is good in many cases"
20,drogus,1652341224.0,4.0,"Python most probably not, but Rust is being slowly introduced in many more domains than JS: embedded programming, kernel, systems programming, games etc. At the same time it \*also\* gets gradually more popular where JS is mostly used like backend services and even frontend code. I strongly doubt that Rust can get popular on the frontend outside of some specific cases where WASM is really a good choice, but I think Rust will be quite big on the server side."
21,vasametropolis,1652326300.0,18.0,"FWIW, I didn't have to disable my adblocker. But I think they know it would work fine and mentioned this anyway."
22,oconnor663,1652301756.0,34.0,"They still ask what languages you _want_ to use next year. I think ""most loved"" is calculated from that."
23,theZcuber,1652301772.0,32.0,"There has never been a question about ""most loved language"". It's inferred from the percent of people who have used it and want to continue using it."
24,OS6aDohpegavod4,1652303148.0,7.0,"There were questions about that, and they're the same as they were before."
25,vtvz,1652341983.0,-2.0,I was confused to
26,FlyingPiranhas,1652333276.0,2.0,I think they use that question to determine whether to give you questions about salary and company size.
27,,1652318600.0,13.0,[removed]
28,ShadowWolf_01,1652291763.0,37.0,What about [Emojicode](https://emojicode.org) though??? It has [safe and unsafe](https://www.emojicode.org/docs/reference/safety.html)!
29,eXoRainbow,1652312372.0,14.0,"[Whitespace](https://esolangs.org/wiki/Whitespace), a language where you only write with whitespace characters such as space and tabs is worth mentioning."
30,rustytoerail,1652363750.0,0.0,[ArnoldC](http://lhartikk.github.io/ArnoldC/)
31,JoshTriplett,1652342792.0,9.0,So are the communities of other languages.
32,mandradon,1652300648.0,40.0,The borrow checker has us at knife point and is making us vote for Rust.
33,eugay,1652300223.0,1.0,Swift?
34,imral,1652328421.0,9.0,"Yeah, I tried it with adblocker on and also didn't encounter any issues."
35,,1652328103.0,6.0,[removed]
36,JonaldLovesDong,1652292309.0,21.0,"I actually contributed a bit to it lol, and I'm the maintainer of the Arch Linux package for it"
37,drogus,1652387250.0,4.0,"I don't think it's about ""the community"". I'm also coding in Ruby, so in a way I'm a part of the Ruby community (and also I contributed to Ruby OSS in the past), but if I could fully switch to Rust I'd do it without any hesitation. I still like Ruby for some stuff, but for the majority of professional work I just feel much better writing Rust - it makes complex system much easier to write and manage, at least in my experience.

I bet there is a lot of people coding professionally in various languages, which they would like to left behind and so far it seems like Rust had the least percentage of people like that."
38,Sapiogram,1652352739.0,0.0,"Not in the same way, I think. Other communities have other semi-arbitrary metrics to rally around."
39,drewsiferr,1652307708.0,7.0,"[Secretly, this is the borrow checker?](https://static.wikia.nocookie.net/villains/images/a/a4/Futurama_Roberto.png/revision/latest?cb=20200521035718)"
40,Trk-5000,1652302764.0,-1.0,"by Rust-based I mean compiles down to Rust, so would therefore have access to the Rust ecosystem (e.g. cargo)

I don’t think Swift can do that"
41,IceSentry,1652382843.0,0.0,Until swift works on anything else other than apple devices I don't see it ever be popular compared to cross platform languages
42,JoshTriplett,1652342660.0,6.0,"Likewise, no issues here either."
43,OS6aDohpegavod4,1652303334.0,14.0,"Rust's ownership semantics are very useful, even if there were GC, so I'm not sure why someone would prefer GC for Rust."
44,jam1garner,1652313086.0,5.0,"Language-level GC'd references\* like early days could be nice, cyclical references and self-referential structs are rough atm. 

imo the parts of borrow checking and ownership (and emergent design choices from those concepts) that are still worth it outside of systems langs:

- immutable by default
- sharing XOR exterior mutability
- references are const by default (so one can reason about mutation)
- race condition prevention due to type-level ownership exclusivity
- destructive moves

Parts that aren't:

- Use-after-drop/liveliness analysis
- Strict rules regarding temporaries 
- explicit differentiation between some thread-safe and thread-unsafe types (wait please let me explain)
- a degree of no-implicit-costs that I love but isn't always needed (you'd want more than your average language still I'd say, but even then things like casting/type coercions/etc can be a bit heavy handed)

I'm not all that crazy about swift but imo there's some really interesting PL work being done. I think a certain degree of additional leniency is possibly with sufficiently clever design and caring a bit less about perf/embedded. (I don't want this for Rust, but for a Rust-inspired language targeting different usecases)

For example, Arc/Rc is a bit annoying a delineation. While we can't statically determine if thread synchronization is needed, we can do a yes/no/maybe of it. And from there auto-demote Arc to Rc, and have Rc be more of a niche type. Similarly, if you can do that with references, you could determine that a lot of references (I'm not discounting GC as the default, but as indicated earlier that's probably not the route I would start) are very short-lived, you can demote them to non-GC'd references. I think the downside here is potential for really hidden perf regressions due to implicit """"""function coloring"""""" (sorta, there's also more strictly local forms of analysis you could do where non-trivial function calls are black boxes but Im not sure I love that).

However I'd say the biggest benefit would be things like possibly having times where temporaries or ""dropped at end of scope while borrowed"" can just be converted to moves (if only one reference exists at the end of scope) or GC'd, having trait objects and polymorphism be nicer in exchange for runtime costs, things like that.

All these thoughts can't exist cohesively in a single design, but imo there's a lot of fat you could trim here and there if you didn't care about every drop of perf or runtime-less usecases. Which route is best, I haven't given enough thought to even pretend I know, but there *are* a lot of interesting routes to explore. I think any of the above ideas would be really hard to make work well, but pre-Rust I'd say the same of borrow checking, or thread safety, or whatever. Just a means of finding out a trick to push all the impossible cases far enough away from common usage to make it so the cases it fails are dwarfed by the value provided. Then finding tricks like NLL where you can push it even further away. To me, applying this principle to higher level languages is looking at the magic optimizing JITs can do with making ""wasteful"" langs efficient with best-effort static analysis to make the simple cases fast. With the caveat that you can also reframe it: take a fast-first language and find how you can cheat with just best-effort analysis to make the hard cases slow (but easy)

Or maybe I'm a fool ignoring evidence of the cascading design choices that makes any of the above quickly devolve into losing too much :P"
45,Trk-5000,1652381970.0,2.0,"In use cases where languages like Go make a bit more sense, such as microservices. In my company it was a struggle to even get people to use Go over Python, I can’t imagine myself preaching Rust.

Sometimes I wish there was a heavily opinionated dialect of Rust designed for the masses. Such a language could maintain interoperability with regular Rust and similar syntax, but would make compromises in places Rust would never compromise (such as performance) for the sake of usability.
It could even serve as a gateway drug to regular Rust.

For example, GC instead of lifetime parameters, goroutines, fewer keywords (dyn?), less glyph-heavy syntax, less Arcs/Rcs/whatever, one string type, etc.

It’s fine, Rust doesn’t have to appeal to every possible use case, but it has some great ideas that are applicable higher up the stack. These ideas are already bleeding into existing languages (Swift, Python, Go) and new languages (V), but it would be much better if we have something closely integrated into the Rust ecosystem."
46,OS6aDohpegavod4,1652314304.0,11.0,">imo the parts of borrow checking and ownership (and emergent design choices from those concepts) that are still worth it outside of systems langs:

> - immutable by default
- sharing XOR exterior mutability
- references are const by default (so one can reason about mutation)
- race condition prevention due to type-level ownership exclusivity
- destructive moves

This isn't covering the biggest benefit of Rust - enforcing proper use of APIs. E.g. Rust is the only mainstream language where you can't try to read from a file handle after it's been closed. That's because closing a file handle takes self, so trying to do anything with the File will be a compile error. That isn't a systems programming concern - it's a general API usage concern.

There are a lot of other examples of this. The Typestate Pattern is very useful for general purpose stuff. Memory safety is just a subset of ""enforcing proper use"" of things."
47,Botahamec,1652437100.0,1.0,Full disclosure: I didn't read the entire thing. But I think the most pedantic parts of Rust that I would want to try fixing are in the first list.
48,OS6aDohpegavod4,1652387637.0,2.0,Why do you think Go is better for microservices than Rust?
49,jam1garner,1652324072.0,2.0,"> This isn't covering the biggest benefit of Rust - enforcing proper use of APIs. E.g. Rust is the only mainstream language where you can't try to read from a file handle after it's been closed. That's because closing a file handle takes self, so trying to do anything with the File will be a compile error

Yes, that would be the ""destructive moves"" bullet point, we are not in disagreement here.

> There are a lot of other examples of this. The Typestate Pattern is very useful for general purpose stuff. Memory safety is just a subset of ""enforcing proper use"" of things.

We are also not in disagreement here. My list was not exhaustive, only parts of ownership and features closely tied to it. I don't think anything regarding my post would have an effect on the typestate pattern. The parts I marked as less important inclusions are ones I didn't find to have much use with regards to correctness. Things like the type system, type inference, lifetimes, exhaustive match, sum types, self-consuming methods, etc were specifically not a part of that. My point was actually specifically that there are parts of the language that could be different for different usecases while also delivering these benefits to those where a system's language might be a non-starter.

There might be a bit of confusion around me mentioning implicit drops at the end of scope, which to me don't serve any purpose. Depending on the semantics of such a language though, you could argue it's hard to distinguish ""important"" ends of scope—drop guards, such as MutexGuard—from variables who are borrowed.

But assuming that's what you're saying (it is different but closely related so I'll go with it) I don't think that's necessarily a hard design problem to work around. One way could be distinguishing the fact a reference to data in a MutexGuard has two degrees of borrowing. The internal data reference borrows from MutexGuard which borrows from Mutex. Rather than one owned object in this chain being borrowed, there are two (Mutex, MutexGuard (yes MutexGuard has a lifetime bound but it is still its own object, the same way &T is an object so if you had &&T you'd have &&T -> &T -> T, with the latter 2 both being borrowed)), so you could apply rules similar to how borrowing a temporary works."
